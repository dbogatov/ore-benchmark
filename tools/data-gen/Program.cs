using System;
using McMaster.Extensions.CommandLineUtils;
using System.ComponentModel.DataAnnotations;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace DataGen
{
	[HelpOption("-?|-h|--help")]
	[Command(Name = "data-gen", Description = "Data generation utility", ThrowOnUnexpectedArgument = true)]
	class Program
	{
		/// <summary>
		/// Entry point
		/// </summary>
		public static int Main(string[] args) => CommandLineApplication.Execute<Program>(args);

		[Option("--data-only", "If present, only data will be generated.", CommandOptionType.NoValue)]
		public bool DataOnly { get; } = false;

		[Option("--queries-only", "If present, only queries will be generated.", CommandOptionType.NoValue)]
		public bool QueriesOnly { get; } = false;

		[Required]
		[FileExists]
		[Option("--dataset <FILE>", Description = "Path to dataset file 'part.tbl' generated by TPC-H.")]
		public string Dataset { get; }

		[Range(10, Int32.MaxValue)]
		[Option("--data <number>", Description = "Max data records to read from dataset file. Default rad everything.")]
		public int DataMax { get; } = 0;

		[Range(10, Int32.MaxValue)]
		[Option("--queries <number>", Description = "Number of queries to generate. Default 100.")]
		public int Count { get; } = 100;

		[Range(0.5, 80)]
		[Option("--range-percent <number>", Description = "Generate ranges of lengths equal to this percent of max. Default 0.5.")]
		public double RangePercent { get; } = 0.5;

		[Option("--seed <number>", Description = "Random seed to use for generation. Default random (depends on system time).")]
		public int Seed { get; } = new Random().Next();

		private int OnExecute()
		{
			if (
				(DataOnly && QueriesOnly) ||
				(!DataOnly && !QueriesOnly)
			)
			{
				throw new ArgumentException($"One and only one of --data-only and --queries-only mst be set.");
			}

			var min = int.MaxValue;
			var max = int.MinValue;

			using (StreamReader sr = File.OpenText(Dataset))
			{
				string line;
				var data = new List<Tuple<int, string>>();
				var read = 0;

				while ((line = sr.ReadLine()) != null)
				{
					var record = line.Split('|');
					var name = record[1];
					var price = Convert.ToInt32(100 * float.Parse(record[7]));

					data.Add(new Tuple<int, string>(price, name));
					read++;

					if (DataMax != 0 && read == DataMax)
					{
						break;
					}
				}

				data.Shuffle(Seed);

				if (DataOnly)
				{
					foreach (var item in data)
					{
						Console.WriteLine($"{item.Item1},\"{item.Item2}\"");
					}
				}

				min = data.Min(i => i.Item1);
				max = data.Max(i => i.Item1);
			}

			if (QueriesOnly)
			{
				var generator = new Random(Seed);
				var rangeLength = Math.Ceiling((max - min) * RangePercent / 100);

				for (int i = 0; i < Count; i++)
				{
					var first = generator.Next(min, max);

					if (first >= max - rangeLength)
					{
						i--;
						continue;
					}
					Console.WriteLine($"{first},{first + rangeLength}");
				}
			}

			return 0;
		}
	}

	public static class Extensions
	{
		// https://stackoverflow.com/a/1262619/1644554
		public static void Shuffle<T>(this IList<T> list, int? seed = null)
		{
			Random rng = seed.HasValue ? new Random(seed.Value) : new Random();

			int n = list.Count;
			while (n > 1)
			{
				n--;
				int k = rng.Next(n + 1);
				T value = list[k];
				list[k] = list[n];
				list[n] = value;
			}
		}
	}
}
